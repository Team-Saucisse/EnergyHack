// This implements a datasource that will fetch data from a JSON web service generated by CodeFluent Entities.

// global for the datasource definition
var codeFluentServiceDataSource = codeFluentServiceDataSource || {};

(function () {
	var DateRegexpConstant = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)$/
	var BlobHandlerPathConstant = "blobhandler.ashx"; // CodeFluent.Runtime.Web.UI.BinaryLargeObjectHttpHandler.HandlerPath

	function ensureUrlEndsWithSlash(url) {
		if (url) {
			if (url.charAt(url.length - 1) != '/') {
				url += '/';
			}
		}
		return url;
	}

	function combineUrls(url1, url2) {
		var url = ensureUrlEndsWithSlash(url1) + url2;
		return url;
	}

	function valueReviver(key, value) {
		if (typeof value === 'string') {
			var result = DateRegexpConstant.exec(value);
			if (result) {
				return new Date(Date.UTC(+result[1], +result[2] - 1, +result[3], +result[4],+result[5], +result[6]));
			}
			else {
			    if (value.substr(0, BlobHandlerPathConstant.length) === BlobHandlerPathConstant) {
			        return combineUrls(Data.serverUrl, value);
			    }
			}
		}
		return value;
	};

    // Definition of the data adapter
    var cfDataAdapter = WinJS.Class.define(
        function (svcUrl, methodName, parameters, properties, resultOptions, methodCallOptions, methodOptions, jsonOptions, culture) {
            // Constructor

            this._pageSize = 10;  // default page size
            this._maxCount = 1000;   // default limit

            this._baseUrl = combineUrls(Data.baseServicesUrl, svcUrl);
            this._getRequest = this._buildGetRequest(this._baseUrl, methodName, parameters, properties, resultOptions, methodCallOptions, methodOptions, jsonOptions, culture);
            this._postRequest = this._buildPostRequest(this._baseUrl, resultOptions, methodCallOptions, methodOptions, jsonOptions, culture);
        },

        // IListDataAdapter interface methods (http://msdn.microsoft.com/en-us/library/windows/apps/br212603.aspx)
        // These define the contract between the virtualized datasource and the data adapter.
        // These methods will be called by virtualized datasource to fetch items, count etc.
        {
            // Called to get a count of the items
            // The value of the count can be updated later in the response to itemsFromIndex
            getCount: function () {
                var that = this;
                var requestStr = that._getRequest;
                //Return the promise from making an XMLHttpRequest to the server

                return WinJS.xhr({
                    headers: { "Content-type": "application/json; charset=utf-8", "If-Modified-Since": "Mon, 27 Mar 1972 00:00:00 GMT" },
                    url: requestStr
                }).then(
                    //Callback for success
                    function (request) {
                        var responseResult = JSON.parse(request.responseText);
                        var total;
                        if (responseResult.rows) {
                            total = responseResult.rows.length;
                        }
                        else if (responseResult.total != 2147483647) {
                            total = responseResult.total;
                        }
                        else {
                            total = 0;
                        }

                        //Service may return a large count of items, but you can only fetch the first 1000, so we max the count at that.
                        try {
                            return Math.min(total, that._maxCount);
                        } catch (err) {
                            return WinJS.Promise.wrapError(new WinJS.ErrorFromName(WinJS.UI.FetchError.noResponse));
                        }
                    },
                    function (request) {
                        if (request.responseText) {
                            var error = JSON.parse(request.responseText);
                            throw error;
                        } else {
                            return WinJS.Promise.wrapError(new WinJS.ErrorFromName(WinJS.UI.FetchError.noResponse));
                        }
                    });
            },

            // Called by the virtualized datasource to fetch items
            // It will request a specific item and hints for a number of items either side of it
            // The implementation should return the specific item, and can choose how many either side
            // to also send back. It can be more or less than those requested.
            //
            // Must return back an object containing fields:
            //   items: The array of items of the form items=[{ key: key1, data : { field1: value, field2: value, ... }}, { key: key2, data : {...}}, ...];
            //   offset: The offset into the array for the requested item
            //   totalCount: (optional) update the value of the count
            itemsFromIndex: function (requestIndex, countBefore, countAfter) {
                var that = this;
                if (requestIndex >= that._maxCount) {
                    return WinJS.Promise.wrapError(new WinJS.ErrorFromName(WinJS.UI.FetchError.doesNotExist));
                }

                //var pageIndex = requestIndex / this._pageSize;
                //var requestStr = that._jsonGetRequest + "&pageSize=" + this._pageSize + "&pageIndex=" + pageIndex;
                var requestStr = that._getRequest;

                //Return the promise from making an XMLHttpRequest to the server
                return WinJS.xhr({
                    headers: { "Content-type": "application/json; charset=utf-8", "If-Modified-Since": "Mon, 27 Mar 1972 00:00:00 GMT" },
                    url: requestStr
                }).then(
                    //Callback for success
                    function (request) {
                        var results = [], count = 0;

                        // Use the JSON parser on the results, safer than eval
                        var responseResult = JSON.parse(request.responseText, valueReviver);

                        // Verify if the service has returned rows
                        if (responseResult.rows) {
                            var items = responseResult.rows;

                            // Data adapter results needs an array of items of the shape:
                            // items =[{ key: key1, data : { field1: value, field2: value, ... }}, { key: key2, data : {...}}, ...];
                            // Source: http://msdn.microsoft.com/en-us/library/windows/apps/br212592.aspx
                            // Form the array of results objects
                            for (var i = 0, itemsLength = items.length; i < itemsLength; i++) {
                                var dataItem = items[i];
                                delete dataItem.[%=CodeFluent.Runtime.Model.ViewPropertyDescriptor.RowId%]; // _rowid is a jqgrid specific field, useless here.
                                results.push({
                                    key: dataItem.EntityKey,
                                    data: dataItem
                                }
                                );
                            }
                            // Get the count from the json
                            count = itemsLength;
                        }
                        // http://msdn.microsoft.com/en-us/library/windows/apps/br212548.aspx
                        return {
                            items: results, // The array of items
                            offset: requestIndex, // The offset into the array for the requested item
                            totalCount: Math.min(count, that._maxCount) // Total count of records
                        };
                    },

                    //Called on an error from the XHR Object
                    function (request) {
                        if (request.responseText) {
                            var error = JSON.parse(request.responseText);
                            throw error;
                        } else {
                            return WinJS.Promise.wrapError(new WinJS.ErrorFromName(WinJS.UI.FetchError.noResponse));
                        }
                    });
            },

            setNotificationHandler: function (notificationHandler) {
                this._notificationHandler = notificationHandler;
            },

            insertAtEnd: function (unused, data) {
                return this.saveInternal(data);
            },

            // change: not implemented on purpose!
            // Implementing change method raises exceptions when used in a ListView (slot.itemNew undefined).

            saveInternal: function (data, raiseChangedEvent) {
                var that = this;
                var requestStr = that._postRequest;
                requestStr += "&type=EntitySaveCall"; // type=ProjectInvokeType.EntitySaveCall;

                return WinJS.xhr({
                    headers: { "Content-type": "json", // this is needed to fool WCF to believe it's not json...
							   "If-Modified-Since": "Mon, 27 Mar 1972 00:00:00 GMT" }, // ensure answer isn't cached by xhr
                    type: "POST",
                    url: requestStr,
                    data: JSON.stringify(data)
                }).then(
                    //Callback for success
                    function (request) {
                        if (request.responseText) {
                            var newItem = JSON.parse(request.responseText, valueReviver);
                            // Update existing object with server values
                            var prop;
                            for (prop in newItem) {
								data[prop] = newItem[prop];
                            }

                            var listItem = {
                                key: data.EntityKey,
                                data: data
                            }
                            if (raiseChangedEvent) {
                                that._notificationHandler.changed(listItem);
                            }
                            return listItem;
                        } else {
                            return;
                        }
                    },

                    //Called on an error from the XHR Object
                    function (request) {
                        if (request.responseText) {
                            var error = JSON.parse(request.responseText);
                            throw error;
                        } else {
                            return WinJS.Promise.wrapError(new WinJS.ErrorFromName(WinJS.UI.EditError.noResponse));
                        }
                    });
            },

            removeInternal: function (parameters) {
                var that = this;
                var requestStr = that._postRequest;
                requestStr += "&type=[%=CodeFluent.Runtime.Model.ProjectInvokeType.EntityDeleteCall%]"; // type=ProjectInvokeType.EntityDeleteCall;

                if (parameters) {
                    var prefix = "[%=CodeFluent.Runtime.Model.ProjectInvokeOptions.MethodParameterDefaultPrefix%]"; // ProjectInvokeOptions.MethodParameterDefaultPrefix
                    var parameterName;
                    for (parameterName in parameters) {
                        if (parameters[parameterName] !== "") {
                            requestStr += "&" + prefix + parameterName + "=" + parameters[parameterName];
                        }
                    }
                } else {
                    return;
                }

                return WinJS.xhr({
                    headers: { "Content-type": "json", // this is needed to fool WCF to believe it's not json...
							   "If-Modified-Since": "Mon, 27 Mar 1972 00:00:00 GMT" }, // ensure answer isn't cached by xhr
                    type: "POST",
                    url: requestStr,
                    data: "" // needs to be an empty string or else we'll have 'undefined' in the body.
                }).then(
                    //Callback for success
                    function (request) {
                        that._notificationHandler.removed(parameters.EntityKey);
                        return;
                    },

                    //Called on an error from the XHR Object
                    function (request) {
                        if (request.responseText) {
                            var error = JSON.parse(request.responseText);
                            throw error;
                        } else {
                            return WinJS.Promise.wrapError(new WinJS.ErrorFromName(WinJS.UI.FetchError.noResponse));
                        }
                    });
            },

            // itemsFromStart: not implemented
            // itemsFromEnd: not implemented
            // itemsFromKey: not implemented
            // itemsFromDescription: not implemented

            
            /******** Private functions *********/

            _buildGetRequest: function (baseUrl, methodName, parameters, properties, resultOptions, methodCallOptions, methodOptions, jsonOptions, culture, viewName, blobFormat) {
                var request = combineUrls(baseUrl, "JsonGet?method=" + methodName);

                if (resultOptions) {
                    request += "&roptions=" + resultOptions;
                } else { 
                    request += "&roptions=[%=(int)(CodeFluent.Runtime.Model.ProjectInvokeResultOptions.JqGridFormat | CodeFluent.Runtime.Model.ProjectInvokeResultOptions.ViewUsesFormat | CodeFluent.Runtime.Model.ProjectInvokeResultOptions.EnsureIdentity | CodeFluent.Runtime.Model.ProjectInvokeResultOptions.EnsureEntityDisplayName | CodeFluent.Runtime.Model.ProjectInvokeResultOptions.WrapExceptionsAsJson | CodeFluent.Runtime.Model.ProjectInvokeResultOptions.TraceExceptions)%]"; // JqGridFormat | ViewUsesFormat | EnsureIdentity | EnsureEntityDisplayName | WrapExceptionsAsJson | TraceExceptions
                }

                if (methodCallOptions) {
                    request += "&coptions=" + methodCallOptions;
                } else {
                    // do nothing
                }

                if (methodOptions) {
                    request += "&moptions=" + methodOptions;
                } else {
                    // do nothing
                }

				if (jsonOptions) {
					request += "&jsoptions=" + jsonOptions;
				} else {
					request += "&jsoptions=[%=(int)(CodeFluent.Runtime.Utilities.JsonSerializationOptions.Default | CodeFluent.Runtime.Utilities.JsonSerializationOptions.DateFormatIso8601)%]"; // Use the ISO 8601 string format for dates (JsonSerializationOptions.Default | JsonSerializationOptions.DateFormatIso8601).
				}

                if (culture) {
                    request += "&culture=" + culture;
                } else {
                    // do nothing
                }

				if (blobFormat) {
                    request += "&bformat=" + blobFormat;
                } else {
                    request += "&bformat=UrlRaw";
                }
                    
                if (viewName) {
                    request += "&view=" + viewName;
                } else {
                    request += "&view=default";
                }

				if (properties) {
					request += "&properties=" + properties;
				} else {
				    // do nothing
				}

                if (parameters) {
                    var prefix = "[%=CodeFluent.Runtime.Model.ProjectInvokeOptions.MethodParameterDefaultPrefix%]";
                    var parameterName;
                    for (parameterName in parameters) {
                        if (parameters[parameterName] !== "") {
                            request += "&" + prefix + parameterName + "=" + parameters[parameterName];
                        }
                    }
                }
				                
                return request;
            },

            _buildPostRequest: function (baseUrl, resultOptions, methodCallOptions, methodOptions, jsonOptions, culture) {
                var request = combineUrls(baseUrl, "JsonPost?");

                if (resultOptions) {
                    request += "roptions=" + resultOptions;
                } else {
                    request += "roptions=[%=(int)(CodeFluent.Runtime.Model.ProjectInvokeResultOptions.JqGridFormat | CodeFluent.Runtime.Model.ProjectInvokeResultOptions.ViewUsesFormat | CodeFluent.Runtime.Model.ProjectInvokeResultOptions.EnsureIdentity | CodeFluent.Runtime.Model.ProjectInvokeResultOptions.EnsureEntityDisplayName | CodeFluent.Runtime.Model.ProjectInvokeResultOptions.WrapExceptionsAsJson | CodeFluent.Runtime.Model.ProjectInvokeResultOptions.TraceExceptions)%]"; // JqGridFormat | ViewUsesFormat | EnsureIdentity | EnsureEntityDisplayName | WrapExceptionsAsJson | TraceExceptions
                }

                if (methodCallOptions) {
                    request += "&coptions=" + methodCallOptions;
                } else {
                    // do nothing
                }

                if (methodOptions) {
                    request += "&moptions=" + methodOptions;
                } else {
                    // do nothing
                }

				if (jsonOptions) {
					request += "&jsoptions=" + jsonOptions;
				} else {
					request += "&jsoptions=[%=(int)(CodeFluent.Runtime.Utilities.JsonSerializationOptions.Default | CodeFluent.Runtime.Utilities.JsonSerializationOptions.DateFormatIso8601)%]"; // Use the ISO 8601 string format for dates (JsonSerializationOptions.Default | JsonSerializationOptions.DateFormatIso8601).
				}

                if (culture) {
                    request += "&culture=" + culture;
                } else {
                    // do nothing
                }
                return request;
            }
        });

    codeFluentServiceDataSource = WinJS.Class.derive(WinJS.UI.VirtualizedDataSource,
        function (entityServiceUrl, methodName, parameters, properties, resultOptions, methodCallOptions, methodOptions, jsonOptions, culture) {
            this._entityServiceUrl = entityServiceUrl;
            this._adapter = new cfDataAdapter(entityServiceUrl, methodName, parameters, properties, resultOptions, methodCallOptions, methodOptions, jsonOptions, culture);
            this._baseDataSourceConstructor(this._adapter);
        },

        {
            // Implement a custom remove method to support concurrency.
            // Expected parameters should be { EntityKey: <key>, RowVersion: <version> }
            remove: function (deleteParameters) {
                this._adapter.removeInternal(deleteParameters);
            },
            
            update: function (data) {
                this._adapter.saveInternal(data, true);
            },
            
            uploadFile: function (propertyName, entityKey, file) {
				var baseUrl = combineUrls(Data.baseServicesUrl, this._entityServiceUrl);
				baseUrl = combineUrls(baseUrl, "JsonPost?roptions=0x2000&properties=");
				var uri = new Windows.Foundation.Uri(baseUrl + propertyName + "&_p_key=" + entityKey);
            
				var contentParts = [];
				var part = new Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart("File", file.name);
				part.setFile(file);
				contentParts.push(part);
            
				var uploader = new Windows.Networking.BackgroundTransfer.BackgroundUploader();
				uploader.createUploadAsync(uri, contentParts).then(function (uploadOperation) {
					uploadOperation.startAsync().then(function () { /*success*/ }, function (error) { throw error; });
				});
            }
		});
})();